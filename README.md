# 代码编写思路

## 1. 先进行Vue实例进行初始化 
      vm._uid = uid++;
      vm._isDue = true;
##    --> init.js

## 2. 对data数据进行初始化 --> proxy.js
  (1) 使用Object.defineProperty()对data中的值进行代理
      如果data是Object类型,就用递归进行层层代理
      如果data是Array类型,就对数组方法进行代理(重写数组方法)
      从而实现对数据的实时监控
  (2) 在数据代理中,要层层进行代理
      使用命名空间进行层层控制
  (3) 在数组代理中使用一个对象重写数组方法,然后对该对象进行代理
      让data中数组的原型指向该对象

## 3. 创建虚拟的节点树     --> mount.js
   (1) el属性是否挂载Dom,没挂载通过$mount()进行挂载
   (2) 创建一个Vnode类,作为产生虚拟节点的工厂
   (3) 通过(深度优先搜索)递归的方式遍历标签childNodes,逐个创建虚拟节点
   (4) 最终形成虚拟的节点树

## 4. 遍历节点树,进行预备渲染;让虚拟节点和模板字符串形成关系
##    即通过模板可以找到对应的虚拟节点
##    通过虚拟节点可以找到对应的虚拟节点
##    --> render.js

    (1) 先通过递归遍历出相应的文本节点
    (2) 通过正则匹配文本节点文本中模板字符串{{}}
    (3) 通过ES6中Map()数据类型来存储(Map可以将对象作为属性进行存储)
        建立两个Map()类型分别来存储

## 5. 渲染节点 进行页面内容的渲染
##    --> rendernode.js

    (1) 先遍历节点虚拟节点树，找到nodeType == 1 的标签节点继续递归
        找到nodeType == 3 的文本节点进行处理
    
    (2) 通过建立的索引关系,用vnode2template.get(vnode)得到对应的模板
    (3) 通过analysisDate()分析数据和模板的关系
        如果模板(obj.x , name)在data中存在，就返回此时的值
        如果模板在data中不存在,就返回undefined,并不对模板进行处理
    (4) 最后通过vnode.elem.nodeValue = 返回的值; 进行页面渲染成功

## 6. 对v-model指令进行解析
##    --> vmodel.js

    (1) 在进行生产虚拟dom树,进行遍历的时候
        对nodeType == 1的标签进行处理
        通过dom.getAttributeNames()得到一个标签属性的数组
        比较该数组中是否有v-model属性

    (2) 对有v-model属性的标签绑定oninput方法
        从而实现双向数据绑定

    (3) 在遍历节点树建立索引的时候
        找到具有v-model属性的节点
        让v-model的属性值和节点建立索引关系
        便于input标签值的渲染

    (4) 在进行页面渲染的时候
        遍历过程中找nodeName == INPUT && nodeType == 1的节点
        通过节点找到对应的v-model的值
        然后进行input中value值的赋值

## 7. 对v-for指令进行解析
##    --> vfor.js

    (1) 在进行生产虚拟dom树时候
        对带有v-for属性的标签进行处理

    (2) 从页面中移除该标签,并且用该标签创建一个虚拟的节点
        用来后面的节点进行渲染  (此节点的nodeType == 0) 

    (3) 首先解析出v-for后面的指令
        (无法通过编译原理进行语法解析,只能通过一定特定的格式来进行v-for循环)
        v-for='(key,index) in list';

    (4) 通过compare方法来比较vm._data中是否有list属性并返回list数组

    (5) 根据数组的长度来创建节点append到虚拟节点的父节点上
        此时index 对应的值就为数组每次循环对应的索引值

    (6) 对数组中对象进行分析,每个对象就是每个标签的env(作用域)
        将env属性设置在标签上
        return {index:i , key:{} };
        该对象用于渲染模板时候值的查找

    (7) 创建节点的时候，遍历到标签上有env属性的时候
        在该节点vnode.env = elem.getAttribute();
        用于渲染节点的时候,对模板进行渲染

    (8) 如果是env属性标签下的文本节点
        就需要继承自己父级的env作为自己的作用域
        在渲染模板时候从env中取值
        
    
## 8. 对v-for指令中list调用push等方法
##    --> vfor.js
    (1) 在proxy.js中检测数组方法的调用
        调用push方法的时候,节点的个数会发生变化,
        根据list循环产生的新的标签数也会变化
        需要重新构建节点树

    (2) 根据作用域得到此时修改的属性值
        根据template2Vnode得到需要修改的虚拟节点
            

    (3) 首先使标签ul li 恢复到为渲染的样子
        然后重新调用创建节点树的方法
        哪个节点发生变化,就从该节点进行节点树的重构
        在节点树重构中,如果是虚拟的节点(nodeType == 0) 
        需要将父级下面所有的子节点push进入自己的children数组中

        重构的节点需要放到父级的children数组中
        关系图

                ul(父节点)

                li(虚拟节点)

            li  li  li (v-for创建的三个新的节点)

    
    (4) 由于节点树的重构,导致节点的索引关系也会变化
        需要将之前的索引关系清空template2Vnode.clear()
        需要重新建立索引关系

    (5) 然后重新进行值的渲染


    


    

    



   

    
      
